---
layout: post
title: training-2016.08.15
subtitle: regular pattern, Count, Lucas, Game and strategy, SG, DP, Search
author: 闫鸿宇
date: 2016-08-15 21:36:31 +0800
categories: [study]
tag: [regular pattern, Count, Lucas, Game and strategy, SG, DP, Search]
comments: true
---
# training-2016.08.15

这场训练的题目在这里[2016 Multi-University Training Contest 6](http://acm.hdu.edu.cn/search.php?field=problem&key=2016+Multi-University+Training+Contest+6&source=1&searchmode=source)  

代码在这里[Our code](https://github.com/New-bottle/training/tree/master/2016summer/160815/)  

### A题
  题意……没啥想说的，打表找规律题，发现ans(n,m) = $ \frac{m^{n + 1} - 1}{m - 1} $

### B题
  题意：国际象棋的马，从(1,1)跳到(n,m)只能向右下跳（即横纵坐标都单调递增），n、m都是10^18，平面上有ｒ(r<=100)个坏点，问不经过任何一个坏点的方案数。　　
  做法：从(x1,y1)到(x2,y2)，只有两种跳法，所以每种跳法的次数是可以解方程解出来的：　　

  - 2x + y = x2 - x1  
  - x + 2y = y2 - y1  

  所以如果不考虑坏点的话用一个组合数就可以算出来了(Lucas定理)  
  然后发现直接容斥是会炸的，我们考虑用dp来做：  
  f[i][0]表示i是最后一个被枚举到的点，且枚举总点数为偶数的，从(1,1)走到第i个坏点的方案数×(-1)
  f[i][1]表示……总点数为奇数……的方案数
  我们令(n,m)为第r + 1个点，则ans为f[r+1][0]+f[r+1][1]，相当于把容斥的过程顺序来做了……
  求f[i]的时候就枚举它之前的点是谁，加过来更新答案。容斥->DP

### C题
  题意：给你n堆石子，你每次可以从任意一堆中取走若干个(>0)，或是将一堆任意分成非空的三堆石子，取得最后一颗石子者胜，问先手胜负？  
  做法：SG函数，sg[0]=0,sg[i] = mex(j),这里的j可以是sg[0~i-1]，还可以是分成的三堆，若是分成三堆则j为sg[x]^sg[y]^sg[i-x-y]。  
  打表找规律发现只有在模8余0和余7处
